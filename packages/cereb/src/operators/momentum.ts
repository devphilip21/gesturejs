import type { ExtendSignalValue, Signal, SignalWith } from "../core/signal.js";
import type { Operator } from "../core/stream.js";
import { createStream } from "../core/stream.js";
import type { Vector } from "../geometry/types.js";

/**
 * Required value properties for momentum operator input.
 * Typically provided by pan signals.
 */
export interface MomentumInput {
  velocity: Vector;
  phase?: "start" | "move" | "end" | "cancel" | string;
}

/**
 * Configuration options for momentum operator.
 */
export interface MomentumOptions {
  /**
   * Friction coefficient applied each frame (0-1).
   * Higher values = faster deceleration.
   * @default 0.95
   */
  friction?: number;

  /**
   * Minimum velocity magnitude to continue momentum.
   * @default 0.1
   */
  minVelocity?: number;

  /**
   * Maximum momentum duration in milliseconds.
   * @default 2000
   */
  maxDuration?: number;
}

/**
 * Values added by momentum operator.
 */
export interface MomentumValue {
  /** Synthetic delta generated by momentum physics */
  momentumDelta: Vector;

  /** Whether this signal is from momentum (true) or direct input (false) */
  isMomentum: boolean;
}

function magnitude(v: Vector): number {
  let sum = 0;
  for (const c of v) {
    sum += c * c;
  }
  return Math.sqrt(sum);
}

/**
 * Creates an operator that adds momentum/inertia after gesture ends.
 *
 * During active gesture: passes signals through with isMomentum=false
 * After gesture ends: generates synthetic signals with decelerating velocity
 *
 * @example
 * ```typescript
 * pan(element)
 *   .pipe(
 *     rotate3d({ sensitivityX: 0.005, sensitivityY: 0.005 }),
 *     momentum({ friction: 0.95, minVelocity: 0.01 })
 *   )
 *   .on(signal => {
 *     if (signal.value.isMomentum) {
 *       // Apply momentum delta
 *       rotationManager.addDelta(...signal.value.momentumDelta);
 *     } else {
 *       // Apply rotation delta (rotate3d outputs delta, not absolute)
 *       rotationManager.addDelta(...signal.value.rotation);
 *     }
 *   });
 * ```
 */
export function momentum<T extends SignalWith<MomentumInput>>(
  options: MomentumOptions = {},
): Operator<T, ExtendSignalValue<T, MomentumValue>> {
  const { friction = 0.95, minVelocity = 0.1, maxDuration = 2000 } = options;

  // friction은 프레임당 유지되는 속도 비율 (0.95 = 95% 유지, 5% 감소)

  type OutputSignal = ExtendSignalValue<T, MomentumValue>;

  return (source) =>
    createStream<OutputSignal>((observer) => {
      let animationId: number | null = null;
      let currentVelocity: Vector | null = null;
      let lastSignal: Signal | null = null;
      let momentumStartTime = 0;

      const stopMomentum = () => {
        if (animationId !== null) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        currentVelocity = null;
        lastSignal = null;
      };

      const runMomentum = () => {
        if (!currentVelocity || !lastSignal) {
          stopMomentum();
          return;
        }

        const elapsed = Date.now() - momentumStartTime;
        if (elapsed > maxDuration) {
          stopMomentum();
          return;
        }

        // Apply decay to velocity (friction = retention ratio per frame)
        currentVelocity = currentVelocity.map((v) => v * friction);

        // Check if velocity is below threshold
        if (magnitude(currentVelocity) < minVelocity) {
          stopMomentum();
          return;
        }

        // Calculate momentum delta (velocity * frame time, assuming ~16ms)
        const momentumDelta = currentVelocity.map((v) => v * 16);

        // Create synthetic momentum signal
        const value = Object.assign({}, lastSignal.value as object, {
          momentumDelta,
          isMomentum: true,
          phase: "momentum",
        }) as MomentumInput & MomentumValue;

        const syntheticSignal = {
          ...lastSignal,
          value,
          updatedAt: Date.now(),
        } as unknown as OutputSignal;

        observer.next(syntheticSignal);

        // Continue momentum loop
        animationId = requestAnimationFrame(runMomentum);
      };

      const unsub = source.on({
        next(signal) {
          try {
            const { velocity, phase } = signal.value;

            // Stop any running momentum when new gesture starts
            if (phase === "start") {
              stopMomentum();
            }

            // Pass through signal with momentum values
            const momentumDelta: Vector = [0, 0];
            const value = signal.value as MomentumInput & MomentumValue;
            value.momentumDelta = momentumDelta;
            value.isMomentum = false;

            observer.next(signal as unknown as OutputSignal);

            // Start momentum on gesture end if velocity is significant
            if (phase === "end" && velocity && magnitude(velocity) >= minVelocity) {
              currentVelocity = [...velocity];
              lastSignal = signal;
              momentumStartTime = Date.now();
              animationId = requestAnimationFrame(runMomentum);
            }

            // Cancel momentum on cancel phase
            if (phase === "cancel") {
              stopMomentum();
            }
          } catch (err) {
            observer.error?.(err);
          }
        },
        error(err) {
          stopMomentum();
          observer.error?.(err);
        },
        complete() {
          stopMomentum();
          observer.complete?.();
        },
      });

      return () => {
        stopMomentum();
        unsub();
      };
    });
}
