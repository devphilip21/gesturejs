---
/**
 * Interactive demo component that draws smooth curves following pointer movement.
 * Uses cereb's singlePointer stream to track pointer events for signature capture.
 */
import "./signature-pad.css";
---
<div class="signature-pad">
  <div id="signature-pad-box" class="_demo-box">
    <canvas id="signature-pad-canvas"></canvas>
    <p id="signature-pad-hint" class="_hint">Sign here.</p>
    <div class="_tip">
      <strong class="_tip-title">Tip.</strong>
      Touch and drag to sign.
    </div>
  </div>
  <div class="_demo-controls">
    <div class="_buttons">
      <button id="clear-canvas" type="button" class="_button">Reset</button>
    </div>
  </div>
  <div id="signature-pad-status" class="_signal-snapshot-grid">
    <strong class="_title">Signal Snapshot</strong>
    <div class="_grid">
      <div class="_item">
        <span class="_label">X</span>
        <span id="info-x" class="_value">-</span>
      </div>
      <div class="_item">
        <span class="_label">Y</span>
        <span id="info-y" class="_value">-</span>
      </div>
      <div class="_item">
        <span class="_label">OFFSET X</span>
        <span id="info-offsetX" class="_value">-</span>
      </div>
      <div class="_item">
        <span class="_label">OFFSET Y</span>
        <span id="info-offsetY" class="_value">-</span>
      </div>
      <div class="_item">
        <span class="_label">PHASE</span>
        <span id="info-phase" class="_value">-</span>
      </div>
      <div class="_item">
        <span class="_label">POINTER TYPE</span>
        <span id="info-type" class="_value">-</span>
      </div>
    </div>
  </div>
</div>

<script>
import { singlePointer, type ExtendSignalValue, type SinglePointerSignal } from "cereb";
import { offset, singlePointerSession } from "cereb/operators";

type Point = { x: number; y: number };
type CanvasSignal = ExtendSignalValue<SinglePointerSignal, { offset: [number, number] }>;

class CanvasManager {
  private ctx: CanvasRenderingContext2D;
  private bgColor: string;
  private animationId: number | null = null;

  constructor(
    private canvas: HTMLCanvasElement,
    private container: HTMLElement
  ) {
    this.ctx = canvas.getContext("2d")!;
    this.bgColor = this.extractBackgroundColor();
    this.setupCanvas();
    this.startFadeAnimation();
  }

  private extractBackgroundColor(): string {
    const computedStyle = getComputedStyle(this.container);
    const boxBg = computedStyle.backgroundColor;

    if (boxBg && boxBg !== "transparent") {
      const match = boxBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (match) {
        return `rgba(${match[1]}, ${match[2]}, ${match[3]}, 0.02)`;
      }
    }
    return "rgba(38, 38, 38, 0.02)";
  }

  private setupCanvas() {
    this.resize();
    window.addEventListener("resize", () => this.resize());
  }

  private resize() {
    const rect = this.container.getBoundingClientRect();
    this.canvas.width = rect.width;
    this.canvas.height = rect.height;
  }

  private startFadeAnimation() {
    const fade = () => {
      this.ctx.fillStyle = this.bgColor;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.animationId = requestAnimationFrame(fade);
    };
    fade();
  }

  drawSmoothCurve(points: Point[], hue: number) {
    if (points.length >= 3) {
      this.drawQuadraticCurve(points, hue);
    } else if (points.length === 2) {
      this.drawLine(points[0], points[1], hue);
    }
  }

  private drawQuadraticCurve(points: Point[], hue: number) {
    const [p0, p1, p2] = points;
    const mid1 = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 };
    const mid2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };

    this.ctx.beginPath();
    this.ctx.moveTo(mid1.x, mid1.y);
    this.ctx.quadraticCurveTo(p1.x, p1.y, mid2.x, mid2.y);
    this.applyStrokeStyle(hue);
    this.ctx.stroke();
  }

  private drawLine(start: Point, end: Point, hue: number) {
    this.ctx.beginPath();
    this.ctx.moveTo(start.x, start.y);
    this.ctx.lineTo(end.x, end.y);
    this.applyStrokeStyle(hue);
    this.ctx.stroke();
  }

  private applyStrokeStyle(hue: number) {
    this.ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
    this.ctx.lineWidth = 3;
    this.ctx.lineCap = "round";
    this.ctx.lineJoin = "round";
  }

  clear() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}

class DrawingState {
  private points: Point[] = [];
  private hue = 0;
  private isDrawing = false;
  private readonly MAX_POINTS = 3;
  private readonly HUE_START_INCREMENT = 30;
  private readonly HUE_MOVE_INCREMENT = 2;

  startDrawing(point: Point) {
    this.isDrawing = true;
    this.points = [{ x: point.x, y: point.y }];
    this.hue = (this.hue + this.HUE_START_INCREMENT) % 360;
  }

  addPoint(point: Point) {
    if (!this.isDrawing) return;

    this.points.push({ x: point.x, y: point.y });
    if (this.points.length > this.MAX_POINTS) {
      this.points.shift();
    }
    this.hue = (this.hue + this.HUE_MOVE_INCREMENT) % 360;
  }

  stopDrawing() {
    this.isDrawing = false;
    this.points = [];
  }

  reset() {
    this.points = [];
    this.isDrawing = false;
  }

  getPoints(): Point[] {
    return this.points;
  }

  getHue(): number {
    return this.hue;
  }

  isActive(): boolean {
    return this.isDrawing;
  }
}

class PointerEventHandler {
  constructor(
    private box: HTMLElement,
    private canvasManager: CanvasManager,
    private drawingState: DrawingState,
    private infoElements: {
      x: HTMLElement;
      y: HTMLElement;
      hint: HTMLElement;
      offsetX: HTMLElement;
      offsetY: HTMLElement;
      phase: HTMLElement;
      type: HTMLElement;
    }
  ) {}

  handlePointer(signal: CanvasSignal) {
    this.updatePointerInfo(signal);

    switch (signal.value.phase) {
      case "start":
        this.infoElements.hint.classList.add("hidden");
        this.handleStart(signal);
        break;
      case "move":
        this.handleMove(signal);
        break;
      case "end":
      case "cancel":
        this.handleEnd();
        break;
    }
  }

  private updatePointerInfo(signal: CanvasSignal) {
    const { cursor, offset, phase, pointerType } = signal.value;
    const [x, y] = cursor;
    const [offsetX, offsetY] = offset;
    this.infoElements.x.textContent = String(Math.round(x));
    this.infoElements.y.textContent = String(Math.round(y));
    this.infoElements.offsetX.textContent = String(Math.round(offsetX));
    this.infoElements.offsetY.textContent = String(Math.round(offsetY));
    this.infoElements.phase.textContent = phase;
    this.infoElements.type.textContent = pointerType;
  }

  private handleStart(signal: CanvasSignal) {
    this.box.classList.add("active");
    const [offsetX, offsetY] = signal.value.offset;
    this.drawingState.startDrawing({ x: offsetX, y: offsetY });
  }

  private handleMove(signal: CanvasSignal) {
    if (!this.drawingState.isActive()) return;

    const [offsetX, offsetY] = signal.value.offset;
    this.drawingState.addPoint({ x: offsetX, y: offsetY });
    this.canvasManager.drawSmoothCurve(
      this.drawingState.getPoints(),
      this.drawingState.getHue()
    );
  }

  private handleEnd() {
    this.drawingState.stopDrawing();
  }
}

function initSignaturePad() {
  const boxEl = document.getElementById("signature-pad-box")!;
  const canvasEl = document.getElementById("signature-pad-canvas")! as HTMLCanvasElement;
  const clearBtnEl = document.getElementById("clear-canvas")!;
  const hintEl = document.getElementById("signature-pad-hint")!;

  const infoXEl = document.getElementById("info-x")!;
  const infoYEl = document.getElementById("info-y")!;
  const infoOffsetXEl = document.getElementById("info-offsetX")!;
  const infoOffsetYEl = document.getElementById("info-offsetY")!;
  const infoPhaseEl = document.getElementById("info-phase")!;
  const infoTypeEl = document.getElementById("info-type")!;

  const canvasManager = new CanvasManager(canvasEl, boxEl);
  const drawingState = new DrawingState();
  const infoElements = { x: infoXEl, y: infoYEl, hint: hintEl, offsetX: infoOffsetXEl, offsetY: infoOffsetYEl, phase: infoPhaseEl, type: infoTypeEl };
  const eventHandler = new PointerEventHandler(boxEl, canvasManager, drawingState, infoElements);

  singlePointer(boxEl)
    .pipe(
      singlePointerSession(),
      offset({ target: boxEl })
    ).on(signal => {
      eventHandler.handlePointer(signal);
    });

  clearBtnEl.addEventListener("click", () => {
    canvasManager.clear();
    drawingState.reset();
    hintEl.classList.remove("hidden");
    infoXEl.textContent = "-";
    infoYEl.textContent = "-";
    infoOffsetXEl.textContent = "-";
    infoOffsetYEl.textContent = "-";
    infoPhaseEl.textContent = "-";
    infoTypeEl.textContent = "-";
  });
}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initSignaturePad);
} else {
  initSignaturePad();
}
</script>
