---
/**
 * Interactive space canvas demo that uses pinch gesture to zoom in/out.
 * Stars and nebulae are drawn on a canvas, with transform applied for zooming.
 */
import "./space-adventure.css";
---

<div class="space-adventure">
  <div class="_demo-box" id="space-box">
    <div class="_canvas-wrapper" id="space-canvas-wrapper">
      <canvas id="space-canvas"></canvas>
    </div>
    <strong id="space-zoom-mode" class="_zoom-mode">Zoom Mode</strong>
    <div class="_tip">
      <strong class="_tip-title">Tip.</strong>
      Drag to rotate. Pinch or double tap to zoom.<br />
      In Desktop, use 'z' + '+/-' or 'wheel' to zoom.
    </div>
  </div>
  <div class="_demo-controls">
    <div class="_slider-container">
      <span class="_slider-label">Zoom</span>
      <input type="range" id="zoom-slider" class="_slider" min="0" max="100" value="50" />
    </div>
    <div class="_buttons">
      <button id="reset-space" type="button" class="_button">Reset</button>
    </div>
  </div>
  <div class="_signal-snapshot-grid" id="space-info-panel">
    <strong class="_title">Signal Snapshot</strong>
    <div class="_grid">
      <div class="_item">
        <span class="_label">SCALE</span>
        <span class="_value" id="info-scale">1.00</span>
      </div>
      <div class="_item">
        <span class="_label">ROTATION</span>
        <span class="_value" id="info-rotation">0, 0</span>
      </div>
      <div class="_item">
        <span class="_label">INPUT</span>
        <span class="_value" id="info-source">-</span>
      </div>
    </div>
  </div>
</div>

<script>
import { wheel, keydown, keyheld, dom, pinch, tap, type SignalWith, pan } from "cereb";
import { zoom as createZoom, extend, when, spy, filter, type ZoomValue, rotate3d } from "cereb/operators";

interface Star {
  x: number;
  y: number;
  z: number;
  baseRadius: number;
  brightness: number;
  twinkleSpeed: number;
  twinklePhase: number;
  color: string;
}

interface ShootingStar {
  x: number;
  y: number;
  angle: number;
  speed: number;
  length: number;
  opacity: number;
  life: number;
  maxLife: number;
}

interface Sun {
  x: number;
  y: number;
  radius: number;
}

interface Planet {
  name: string;
  orbitRadius: number;
  orbitAngle: number;
  orbitSpeed: number;
  rotationAngle: number;
  rotationSpeed: number;
  radius: number;
  color: string;
  hasRings?: boolean;
}

/**
 * Renders a 3D parallax space scene with multiple star layers,
 * animated nebulae, occasional shooting stars, and a solar system.
 *
 * Uses a virtual world coordinate system (6x canvas size) to enable
 * zoom-out without showing empty edges. All rendering is done by
 * transforming world coordinates to canvas coordinates based on
 * current scale and center position.
 */
class SpaceRenderer {
  private ctx: CanvasRenderingContext2D;
  private starLayers: Star[][] = [];
  private shootingStars: ShootingStar[] = [];
  private sun!: Sun;
  private planets: Planet[] = [];
  private animationId: number | null = null;
  private driftX = 0;
  private driftY = 0;
  private readonly LAYER_COUNT = 4;
  private readonly LAYER_SPEEDS = [0.02, 0.05, 0.1, 0.2];

  // Virtual world is 6x canvas size to fit full solar system
  private readonly WORLD_SCALE = 6;
  private worldWidth = 0;
  private worldHeight = 0;

  // Current view state
  private viewScale = 1;
  private viewCenterX = 0.5; // 0~1 ratio within world
  private viewCenterY = 0.5;

  // 3D rotation state (radians)
  private rotationX = 0;  // pitch (vertical rotation)
  private rotationY = 0;  // yaw (horizontal rotation)

  constructor(
    private canvas: HTMLCanvasElement,
    private container: HTMLElement
  ) {
    this.ctx = canvas.getContext("2d")!;
    this.setupCanvas();
    this.generateSpace();
    this.startAnimation();
  }

  private setupCanvas() {
    this.resize();
    window.addEventListener("resize", () => {
      this.resize();
      this.generateSpace();
    });
  }

  private resize() {
    const rect = this.container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    // Virtual world is 4x canvas size
    this.worldWidth = this.canvas.width * this.WORLD_SCALE;
    this.worldHeight = this.canvas.height * this.WORLD_SCALE;
  }

  /**
   * Updates the view state for zoom/pan.
   * @param scale - Zoom scale (1 = normal, 0.25 = zoomed out to see full world)
   * @param centerX - View center X as ratio (0~1) within world
   * @param centerY - View center Y as ratio (0~1) within world
   */
  setView(scale: number, centerX: number, centerY: number) {
    this.viewScale = scale;
    this.viewCenterX = centerX;
    this.viewCenterY = centerY;
  }

  getViewScale() {
    return this.viewScale;
  }

  /**
   * Sets 3D rotation angles for the space view.
   */
  setRotation(rx: number, ry: number) {
    this.rotationX = rx;
    this.rotationY = ry;
  }

  getRotation(): [number, number] {
    return [this.rotationX, this.rotationY];
  }

  /**
   * Projects a 3D world coordinate to 2D screen coordinates with rotation applied.
   * Returns [screenX, screenY, depth] where depth can be used for z-sorting.
   */
  private project3D(wx: number, wy: number, wz: number): [number, number, number] {
    // Center of the world
    const centerX = this.worldWidth / 2;
    const centerY = this.worldHeight / 2;

    // Translate to origin
    let x = wx - centerX;
    let y = wy - centerY;
    let z = wz;

    // Apply Y-axis rotation (yaw - horizontal pan)
    const cosY = Math.cos(this.rotationY);
    const sinY = Math.sin(this.rotationY);
    const x1 = x * cosY - z * sinY;
    const z1 = x * sinY + z * cosY;

    // Apply X-axis rotation (pitch - vertical pan)
    const cosX = Math.cos(this.rotationX);
    const sinX = Math.sin(this.rotationX);
    const y1 = y * cosX - z1 * sinX;
    const z2 = y * sinX + z1 * cosX;

    // Translate back from origin
    const rx = x1 + centerX;
    const ry = y1 + centerY;

    // Perspective projection
    const focalLength = this.worldWidth * 0.8;
    const projectionScale = focalLength / (focalLength + z2);

    const screenX = centerX + (rx - centerX) * projectionScale;
    const screenY = centerY + (ry - centerY) * projectionScale;

    return [screenX, screenY, z2];
  }

  /**
   * Transforms world coordinates to canvas coordinates based on current view.
   */
  private worldToCanvas(wx: number, wy: number): [number, number] {
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    // Viewport size in world coordinates (smaller scale = larger viewport)
    const viewportW = canvasW / this.viewScale;
    const viewportH = canvasH / this.viewScale;

    // Viewport center in world coordinates
    const viewCenterWX = this.worldWidth * this.viewCenterX;
    const viewCenterWY = this.worldHeight * this.viewCenterY;

    // Viewport top-left in world coordinates
    const viewX = viewCenterWX - viewportW / 2;
    const viewY = viewCenterWY - viewportH / 2;

    // Transform world to canvas
    const cx = (wx - viewX) * this.viewScale;
    const cy = (wy - viewY) * this.viewScale;

    return [cx, cy];
  }

  /**
   * Transforms a radius from world space to canvas space.
   */
  private worldRadiusToCanvas(radius: number): number {
    return radius * this.viewScale;
  }

  private generateSpace() {
    this.generateStarLayers();
    this.generateSolarSystem();
  }

  private generateSolarSystem() {
    this.sun = {
      x: this.worldWidth / 2,
      y: this.worldHeight / 2,
      radius: 80,
    };

    // Distances spread to fill view at minimum zoom
    this.planets = [
      {
        name: "mercury",
        orbitRadius: 250,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0020,
        rotationAngle: 0,
        rotationSpeed: 0.004,
        radius: 10,
        color: "#b5b5b5",
      },
      {
        name: "venus",
        orbitRadius: 450,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0014,
        rotationAngle: 0,
        rotationSpeed: 0.003,
        radius: 32,
        color: "#e6c87a",
      },
      {
        name: "earth",
        orbitRadius: 650,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0008,
        rotationAngle: 0,
        rotationSpeed: 0.015,
        radius: 36,
        color: "#4a90d9",
      },
      {
        name: "mars",
        orbitRadius: 900,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0006,
        rotationAngle: 0,
        rotationSpeed: 0.014,
        radius: 18,
        color: "#c1440e",
      },
      {
        name: "jupiter",
        orbitRadius: 1300,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00035,
        rotationAngle: 0,
        rotationSpeed: 0.025,
        radius: 85,
        color: "#d4a574",
      },
      {
        name: "saturn",
        orbitRadius: 1800,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00025,
        rotationAngle: 0,
        rotationSpeed: 0.022,
        radius: 70,
        color: "#e8d5a3",
        hasRings: true,
      },
      {
        name: "uranus",
        orbitRadius: 2350,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00018,
        rotationAngle: 0,
        rotationSpeed: 0.018,
        radius: 45,
        color: "#7de3e3",
      },
      {
        name: "neptune",
        orbitRadius: 2900,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00012,
        rotationAngle: 0,
        rotationSpeed: 0.016,
        radius: 42,
        color: "#5b8edd",
      },
    ];
  }

  private generateStarLayers() {
    this.starLayers = [];
    const starColors = ["#ffffff", "#ffe8d0", "#d0e8ff", "#ffd8e8", "#d8ffe8", "#e8d8ff"];

    // Generate stars across the entire virtual world
    for (let layer = 0; layer < this.LAYER_COUNT; layer++) {
      const stars: Star[] = [];
      const layerDepth = (layer + 1) / this.LAYER_COUNT;
      // Increased star count (1.5x more stars)
      const starCount = Math.floor((75 + (1 - layerDepth) * 225) * this.WORLD_SCALE);

      // Each layer covers a depth range for parallax effect
      const depthMin = layer / this.LAYER_COUNT;
      const depthMax = (layer + 1) / this.LAYER_COUNT;

      for (let i = 0; i < starCount; i++) {
        const depth = depthMin + Math.random() * (depthMax - depthMin);
        const isBright = Math.random() < 0.05 + depth * 0.1;
        stars.push({
          x: Math.random() * this.worldWidth,
          y: Math.random() * this.worldHeight,
          z: depth,
          // Increased base radius so stars remain visible when zoomed out
          baseRadius: isBright ? 2.5 + Math.random() * 3.0 : 0.8 + Math.random() * 1.5,
          brightness: 0.4 + Math.random() * 0.6,
          twinkleSpeed: 0.3 + Math.random() * 1.5,
          twinklePhase: Math.random() * Math.PI * 2,
          color: starColors[Math.floor(Math.random() * starColors.length)],
        });
      }
      this.starLayers.push(stars);
    }
  }

  private spawnShootingStar() {
    if (this.shootingStars.length >= 2 || Math.random() > 0.002) return;

    // Spawn shooting stars in the virtual world
    this.shootingStars.push({
      x: Math.random() * this.worldWidth,
      y: Math.random() * this.worldHeight * 0.3,
      angle: Math.PI * 0.2 + Math.random() * Math.PI * 0.2,
      speed: 4 + Math.random() * 4,
      length: 60 + Math.random() * 80,
      opacity: 0.8 + Math.random() * 0.2,
      life: 0,
      maxLife: 80 + Math.random() * 40,
    });
  }

  private startAnimation() {
    let lastTime = 0;
    const animate = (time: number) => {
      const delta = Math.min((time - lastTime) / 16.67, 2);
      lastTime = time;

      this.driftX += 0.015 * delta;
      this.driftY += 0.008 * delta;

      this.spawnShootingStar();
      this.render(time, delta);
      this.animationId = requestAnimationFrame(animate);
    };
    this.animationId = requestAnimationFrame(animate);
  }

  private render(time: number, delta: number) {
    const ctx = this.ctx;
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    // Clear with background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvasH);
    gradient.addColorStop(0, "#05050f");
    gradient.addColorStop(0.5, "#0a0a1a");
    gradient.addColorStop(1, "#080815");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvasW, canvasH);

    this.renderStarLayers(ctx, time);
    this.renderOrbitPaths(ctx);
    this.renderSolarSystem(ctx, time, delta);
    this.renderShootingStars(ctx, delta);
  }

  private renderSolarSystem(ctx: CanvasRenderingContext2D, time: number, delta: number) {
    // Update all planet positions first
    for (const planet of this.planets) {
      planet.orbitAngle += planet.orbitSpeed * delta;
      planet.rotationAngle += planet.rotationSpeed * delta;
    }

    // Calculate actual 3D depth for each planet after rotation
    const getPlanetDepth = (p: Planet) => {
      const wx = this.sun.x + Math.cos(p.orbitAngle) * p.orbitRadius;
      const wy = this.sun.y;
      const wz = Math.sin(p.orbitAngle) * p.orbitRadius;
      const [, , depth] = this.project3D(wx, wy, wz);
      return depth;
    };

    // Sun is at z=0, get its depth after rotation
    const [, , sunDepth] = this.project3D(this.sun.x, this.sun.y, 0);

    // Separate planets into behind and in front of sun
    const behindSun = this.planets.filter(p => getPlanetDepth(p) > sunDepth);
    const inFrontOfSun = this.planets.filter(p => getPlanetDepth(p) <= sunDepth);

    // Sort each group by depth (far to near)
    behindSun.sort((a, b) => getPlanetDepth(b) - getPlanetDepth(a));
    inFrontOfSun.sort((a, b) => getPlanetDepth(b) - getPlanetDepth(a));

    // Draw: planets behind -> sun -> planets in front
    this.renderPlanetGroup(ctx, behindSun);
    this.renderSun(ctx, time);
    this.renderPlanetGroup(ctx, inFrontOfSun);
  }

  private renderStarLayers(ctx: CanvasRenderingContext2D, time: number) {
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    // Collect all stars with their projected positions for depth sorting
    const projectedStars: Array<{
      star: Star;
      x: number;
      y: number;
      depth: number;
      brightness: number;
    }> = [];

    for (let layerIdx = 0; layerIdx < this.starLayers.length; layerIdx++) {
      const layer = this.starLayers[layerIdx];
      const speed = this.LAYER_SPEEDS[layerIdx];

      for (const star of layer) {
        const parallaxX = this.driftX * speed * 50;
        const parallaxY = this.driftY * speed * 50;

        // World coordinates with parallax and wrapping
        let worldX = (star.x - parallaxX) % this.worldWidth;
        let worldY = (star.y - parallaxY) % this.worldHeight;
        if (worldX < 0) worldX += this.worldWidth;
        if (worldY < 0) worldY += this.worldHeight;

        // Convert star.z (0~1) to actual 3D depth (-2000 to 2000)
        const worldZ = (star.z - 0.5) * 4000;

        // Apply 3D rotation and project to 2D
        const [projX, projY, depth] = this.project3D(worldX, worldY, worldZ);

        // Transform projected world coordinates to canvas coordinates
        const [x, y] = this.worldToCanvas(projX, projY);

        // Cull if outside visible area
        if (x < -10 || x > canvasW + 10 || y < -10 || y > canvasH + 10) continue;

        const twinkle = Math.sin(time * 0.001 * star.twinkleSpeed + star.twinklePhase);
        const currentBrightness = star.brightness * (0.6 + twinkle * 0.4);

        projectedStars.push({ star, x, y, depth, brightness: currentBrightness });
      }
    }

    // Sort by depth (far to near) for proper rendering order
    projectedStars.sort((a, b) => b.depth - a.depth);

    // Render sorted stars
    for (const { star, x, y, depth, brightness } of projectedStars) {
      // Depth-based scaling (closer = larger, farther = smaller)
      const depthFactor = 1 - depth / 8000; // Normalize depth to 0~1 range
      const depthScale = Math.max(0.3, Math.min(1.5, 0.5 + depthFactor));
      const worldRadius = star.baseRadius * depthScale;
      const radius = Math.max(0.4, this.worldRadiusToCanvas(worldRadius));

      ctx.globalAlpha = brightness * depthScale;
      ctx.fillStyle = star.color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();

      if (radius > 1.5 && brightness > 0.7) {
        const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 5);
        glowGradient.addColorStop(0, star.color);
        glowGradient.addColorStop(0.3, star.color.replace(")", ", 0.3)").replace("rgb", "rgba"));
        glowGradient.addColorStop(1, "transparent");
        ctx.fillStyle = glowGradient;
        ctx.globalAlpha = brightness * 0.25;
        ctx.beginPath();
        ctx.arc(x, y, radius * 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
  }

  private renderShootingStars(ctx: CanvasRenderingContext2D, delta: number) {
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    for (let i = this.shootingStars.length - 1; i >= 0; i--) {
      const star = this.shootingStars[i];
      star.life += delta;
      // Update position in world coordinates
      star.x += Math.cos(star.angle) * star.speed * delta;
      star.y += Math.sin(star.angle) * star.speed * delta;

      const lifeRatio = star.life / star.maxLife;
      const fadeIn = Math.min(lifeRatio * 5, 1);
      const fadeOut = 1 - Math.pow(lifeRatio, 2);
      const opacity = star.opacity * fadeIn * fadeOut;

      // Remove if life expired or outside world
      if (star.life >= star.maxLife || star.x > this.worldWidth + 50 || star.y > this.worldHeight + 50) {
        this.shootingStars.splice(i, 1);
        continue;
      }

      // Transform to canvas coordinates
      const [headX, headY] = this.worldToCanvas(star.x, star.y);
      const tailWorldX = star.x - Math.cos(star.angle) * star.length;
      const tailWorldY = star.y - Math.sin(star.angle) * star.length;
      const [tailX, tailY] = this.worldToCanvas(tailWorldX, tailWorldY);

      // Cull if completely outside canvas
      if (Math.max(headX, tailX) < 0 || Math.min(headX, tailX) > canvasW ||
          Math.max(headY, tailY) < 0 || Math.min(headY, tailY) > canvasH) continue;

      const gradient = ctx.createLinearGradient(tailX, tailY, headX, headY);
      gradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
      gradient.addColorStop(0.7, `rgba(200, 220, 255, ${opacity * 0.5})`);
      gradient.addColorStop(1, `rgba(255, 255, 255, ${opacity})`);

      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2 * this.viewScale;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();

      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.beginPath();
      ctx.arc(headX, headY, 2 * this.viewScale, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  private renderOrbitPaths(ctx: CanvasRenderingContext2D) {
    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
    ctx.lineWidth = 1.5;

    // Draw orbits as 3D circles by sampling points
    const ORBIT_SEGMENTS = 64;
    for (const planet of this.planets) {
      ctx.beginPath();
      for (let i = 0; i <= ORBIT_SEGMENTS; i++) {
        const angle = (i / ORBIT_SEGMENTS) * Math.PI * 2;
        const wx = this.sun.x + Math.cos(angle) * planet.orbitRadius;
        const wy = this.sun.y;
        const wz = Math.sin(angle) * planet.orbitRadius;

        const [px, py] = this.project3D(wx, wy, wz);
        const [cx, cy] = this.worldToCanvas(px, py);

        if (i === 0) {
          ctx.moveTo(cx, cy);
        } else {
          ctx.lineTo(cx, cy);
        }
      }
      ctx.stroke();
    }
  }

  private renderSun(ctx: CanvasRenderingContext2D, _time: number) {
    // Sun is at center (z=0)
    const [px, py] = this.project3D(this.sun.x, this.sun.y, 0);
    const [x, y] = this.worldToCanvas(px, py);
    const radius = this.worldRadiusToCanvas(this.sun.radius);

    // Cull if outside visible area
    if (x + radius * 3 < 0 || x - radius * 3 > this.canvas.width ||
        y + radius * 3 < 0 || y - radius * 3 > this.canvas.height) return;

    // Outer corona glow
    const coronaGradient = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2.5);
    coronaGradient.addColorStop(0, "rgba(255, 200, 100, 0.3)");
    coronaGradient.addColorStop(0.4, "rgba(255, 150, 50, 0.15)");
    coronaGradient.addColorStop(1, "rgba(255, 100, 0, 0)");
    ctx.fillStyle = coronaGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius * 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Main sun body
    const sunGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    sunGradient.addColorStop(0, "#fffef0");
    sunGradient.addColorStop(0.3, "#ffee88");
    sunGradient.addColorStop(0.7, "#ffcc33");
    sunGradient.addColorStop(1, "#ff8800");
    ctx.fillStyle = sunGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();

    // Inner bright core
    const coreGradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 0.4);
    coreGradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
    coreGradient.addColorStop(1, "rgba(255, 255, 200, 0)");
    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }

  private renderPlanetGroup(ctx: CanvasRenderingContext2D, planets: Planet[]) {
    for (const planet of planets) {
      // Calculate planet's 3D world position (orbit in xz plane)
      const planetWorldX = this.sun.x + Math.cos(planet.orbitAngle) * planet.orbitRadius;
      const planetWorldY = this.sun.y;
      const planetWorldZ = Math.sin(planet.orbitAngle) * planet.orbitRadius;

      // Project to 2D with rotation
      const [px, py, depth] = this.project3D(planetWorldX, planetWorldY, planetWorldZ);
      const [x, y] = this.worldToCanvas(px, py);

      // Scale radius based on depth (perspective)
      const focalLength = this.worldWidth * 0.8;
      const perspectiveScale = focalLength / (focalLength + depth);
      const radius = this.worldRadiusToCanvas(planet.radius) * perspectiveScale;

      // Cull if outside visible area
      const cullRadius = planet.hasRings ? radius * 2.5 : radius;
      if (x + cullRadius < 0 || x - cullRadius > this.canvas.width ||
          y + cullRadius < 0 || y - cullRadius > this.canvas.height) continue;

      // Draw Saturn's rings behind the planet
      if (planet.hasRings) {
        this.renderSaturnRings(ctx, x, y, radius, planet.rotationAngle);
      }

      // Draw planet body with crisp edges
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.clip();

      // Planet gradient
      const planetGradient = ctx.createRadialGradient(
        x - radius * 0.3, y - radius * 0.3, 0,
        x, y, radius
      );

      if (planet.name === "earth") {
        // Earth with continents
        planetGradient.addColorStop(0, "#4a90d9");
        planetGradient.addColorStop(0.5, "#2e6ab3");
        planetGradient.addColorStop(1, "#1a4a7a");
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

        // Continents
        const continentOffset = planet.rotationAngle * 0.5;
        ctx.fillStyle = "#3d8b4a";
        for (let i = 0; i < 3; i++) {
          const angle = continentOffset + (i * Math.PI * 2) / 3;
          const cx = x + Math.cos(angle) * radius * 0.4;
          const cy = y + Math.sin(angle * 0.5) * radius * 0.3;
          ctx.beginPath();
          ctx.ellipse(cx, cy, radius * 0.35, radius * 0.25, angle, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (planet.name === "jupiter") {
        // Jupiter with bands
        planetGradient.addColorStop(0, "#e8cba8");
        planetGradient.addColorStop(0.5, "#d4a574");
        planetGradient.addColorStop(1, "#a67c52");
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

        // Horizontal bands
        ctx.fillStyle = "rgba(180, 120, 80, 0.4)";
        for (let i = -2; i <= 2; i++) {
          ctx.fillRect(x - radius, y + i * radius * 0.3 - radius * 0.08, radius * 2, radius * 0.16);
        }
      } else if (planet.name === "mars") {
        // Mars with polar caps
        planetGradient.addColorStop(0, "#e07050");
        planetGradient.addColorStop(0.5, "#c1440e");
        planetGradient.addColorStop(1, "#8b3010");
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

        // Polar cap
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.ellipse(x, y - radius * 0.7, radius * 0.4, radius * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Generic planet
        const baseColor = planet.color;
        const r = parseInt(baseColor.slice(1, 3), 16);
        const g = parseInt(baseColor.slice(3, 5), 16);
        const b = parseInt(baseColor.slice(5, 7), 16);

        planetGradient.addColorStop(0, `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`);
        planetGradient.addColorStop(0.5, baseColor);
        planetGradient.addColorStop(1, `rgb(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)})`);
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
      }

      // Day/night shadow (direction from planet to sun in screen space)
      const [sunPx, sunPy] = this.project3D(this.sun.x, this.sun.y, 0);
      const [sunX, sunY] = this.worldToCanvas(sunPx, sunPy);
      const sunAngle = Math.atan2(sunY - y, sunX - x);
      const shadowGradient = ctx.createRadialGradient(
        x + Math.cos(sunAngle) * radius * 0.5,
        y + Math.sin(sunAngle) * radius * 0.5,
        0,
        x - Math.cos(sunAngle) * radius * 0.3,
        y - Math.sin(sunAngle) * radius * 0.3,
        radius * 1.2
      );
      shadowGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
      shadowGradient.addColorStop(0.5, "rgba(0, 0, 20, 0.3)");
      shadowGradient.addColorStop(1, "rgba(0, 0, 30, 0.7)");
      ctx.fillStyle = shadowGradient;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

      ctx.restore();
    }
  }

  private renderSaturnRings(ctx: CanvasRenderingContext2D, x: number, y: number, planetRadius: number, _rotation: number) {
    const innerRadius = planetRadius * 1.3;
    const outerRadius = planetRadius * 2.2;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(1, 0.3); // Tilt the rings

    // Ring gradient
    const ringGradient = ctx.createRadialGradient(0, 0, innerRadius, 0, 0, outerRadius);
    ringGradient.addColorStop(0, "rgba(210, 180, 140, 0)");
    ringGradient.addColorStop(0.1, "rgba(210, 180, 140, 0.6)");
    ringGradient.addColorStop(0.3, "rgba(180, 150, 110, 0.4)");
    ringGradient.addColorStop(0.5, "rgba(210, 180, 140, 0.5)");
    ringGradient.addColorStop(0.7, "rgba(180, 150, 110, 0.3)");
    ringGradient.addColorStop(1, "rgba(210, 180, 140, 0)");

    ctx.fillStyle = ringGradient;
    ctx.beginPath();
    ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
    ctx.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
    ctx.fill();

    ctx.restore();
  }

  regenerate() {
    this.driftX = 0;
    this.driftY = 0;
    this.shootingStars = [];
    this.viewScale = 1;
    this.viewCenterX = 0.5;
    this.viewCenterY = 0.5;
    this.rotationX = 0;
    this.rotationY = 0;
    this.generateSpace();
  }

  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}

/**
 * Manages zoom state and updates SpaceRenderer's view.
 * No CSS transforms - all zooming is handled by the renderer's coordinate system.
 */
class ZoomManager {
  private currentScale = 1;
  private baseScale = 1;
  private centerX = 0.5; // View center as ratio (0~1) in world
  private centerY = 0.5;

  constructor(
    private container: HTMLElement,
    private renderer: SpaceRenderer,
  ) {
    this.applyView();
  }

  private applyView() {
    this.renderer.setView(this.currentScale, this.centerX, this.centerY);
  }

  reset() {
    this.currentScale = 1;
    this.baseScale = 1;
    this.centerX = 0.5;
    this.centerY = 0.5;
    this.applyView();
  }

  getScale() {
    return this.currentScale;
  }

  setScale(newScale: number) {
    this.currentScale = newScale;
    this.applyView();
  }

  adjustScale(delta: number) {
    this.setScale(this.currentScale + delta);
  }
}

/**
 * Manages 3D rotation state and applies to SpaceRenderer.
 */
class RotationManager {
  // Initial tilt of ~25° on X-axis for better 3D perspective
  private static readonly INITIAL_ROTATION: [number, number, number] = [0.45, 0, 0];
  private rotation: [number, number, number] = [...RotationManager.INITIAL_ROTATION];

  constructor(private renderer: SpaceRenderer) {
    this.applyRotation();
  }

  private applyRotation() {
    this.renderer.setRotation(this.rotation[0], this.rotation[1]);
  }

  getRotation(): [number, number, number] {
    return [...this.rotation];
  }

  setRotation(x: number, y: number, z: number) {
    this.rotation = [x, y, z];
    this.applyRotation();
  }

  addDelta(dx: number, dy: number, dz: number) {
    this.rotation[0] += dx;
    this.rotation[1] += dy;
    this.rotation[2] += dz;
    this.applyRotation();
  }

  reset() {
    this.rotation = [...RotationManager.INITIAL_ROTATION];
    this.applyRotation();
  }
}

function initSpacePinchZoom() {
  const box = document.getElementById("space-box");
  const canvas = document.getElementById("space-canvas") as HTMLCanvasElement;
  const resetBtn = document.getElementById("reset-space");
  const slider = document.getElementById("zoom-slider") as HTMLInputElement;
  const infoScale = document.getElementById("info-scale");
  const infoRotation = document.getElementById("info-rotation");
  const infoSource = document.getElementById("info-source");

  if (!box || !canvas || !resetBtn || !slider || !infoScale || !infoRotation || !infoSource) {
    return;
  }

  const MIN_SCALE = 0.2;
  const MAX_SCALE = 5;
  const logMin = Math.log(MIN_SCALE);
  const logMax = Math.log(MAX_SCALE);

  const spaceRenderer = new SpaceRenderer(canvas, box);
  const zoomManager = new ZoomManager(box, spaceRenderer);
  const rotationManager = new RotationManager(spaceRenderer);

  const syncSlider = (scale: number) => {
    const logScale = Math.log(scale);
    const value = ((logScale - logMin) / (logMax - logMin)) * 100;
    slider.value = String(value);
  };

  const updateZoomInfo = (source: string) => {
    infoScale.textContent = zoomManager.getScale().toFixed(2);
    infoSource.textContent = source;
    syncSlider(zoomManager.getScale());
  };

  const updateRotationInfo = (source?: string) => {
    const [rx, ry] = rotationManager.getRotation();
    infoRotation.textContent = `${(rx * 180 / Math.PI).toFixed(0)}°, ${(ry * 180 / Math.PI).toFixed(0)}°`;
    if (source) infoSource.textContent = source;
  };

  syncSlider(zoomManager.getScale());

  // Show initial rotation
  updateRotationInfo();

  resetBtn.addEventListener("click", () => {
    zoomManager.reset();
    rotationManager.reset();
    spaceRenderer.regenerate();
    box.classList.remove("active");
    syncSlider(1);
    infoScale.textContent = "1.00";
    updateRotationInfo();
    infoSource.textContent = "-";
  });

  // Helper to apply scale delta with clamping
  const applyZoomDelta = (delta: number, source: string) => {
    const newScale = clamp(zoomManager.getScale() + delta, MIN_SCALE, MAX_SCALE);
    zoomManager.setScale(newScale);
    updateZoomInfo(source);
  };

  const zoomMode$ = keyheld(window, { code: "KeyZ" }).pipe(extend((signal) => ({ opened: signal.value.held })));
  const zoomModeIndicator = document.getElementById("space-zoom-mode");

  zoomMode$.on((signal) => {
    zoomModeIndicator?.classList.toggle("active", signal.value.held);
  });

  // Pinch Zoom (continuous gesture - uses zoom operator for delta)
  const PINCH_SENSITIVITY = 0.4; // 0~1, lower = less sensitive
  pinch(box, { threshold: 10 })
    .pipe(
      extend((signal) => ({
        ratio: 1 + (signal.value.ratio - 1) * PINCH_SENSITIVITY,
      })),
      createZoom(),
    )
    .on((signal) => {
      applyZoomDelta(signal.value.scale, signal.kind);
    });

  // Double Tap Zoom (discrete - set absolute scale directly)
  const DOUBLE_TAP_ZOOM_MULTIPLIER = 2.5;
  tap(box, { chainIntervalThreshold: 300 })
    .pipe(filter((signal) => signal.value.tapCount === 2))
    .on(() => {
      const currentScale = zoomManager.getScale();
      const isNearMax = currentScale >= MAX_SCALE * 0.9;
      const targetScale = isNearMax ? 1 : Math.min(currentScale * DOUBLE_TAP_ZOOM_MULTIPLIER, MAX_SCALE);
      zoomManager.setScale(targetScale);
      updateZoomInfo("tap");
    });

  // 'z' + '+/-' (discrete - compute delta directly)
  keydown(window, { code: ["Equal", "Minus"] })
    .pipe(
      when(zoomMode$),
      spy((signal) => signal.value.originalEvent.preventDefault()),
    )
    .on((signal) => {
      const currentScale = zoomManager.getScale();
      const multiplier = signal.value.code === "Equal" ? 1.2 : 1 / 1.2;
      const targetScale = clamp(currentScale * multiplier, MIN_SCALE, MAX_SCALE);
      zoomManager.setScale(targetScale);
      updateZoomInfo("keydown");
    });

  // 'z' + 'wheel' (discrete per event - compute delta directly)
  wheel(box, { passive: false })
    .pipe(
      when(zoomMode$),
      spy((signal) => signal.value.originalEvent.preventDefault()),
    )
    .on((signal) => {
      const currentScale = zoomManager.getScale();
      const multiplier = Math.exp(-signal.value.deltaY * 0.005);
      const targetScale = clamp(currentScale * multiplier, MIN_SCALE, MAX_SCALE);
      zoomManager.setScale(targetScale);
      updateZoomInfo("wheel");
    });

  // Slider - sets absolute scale directly
  dom(slider, "input").on((signal) => {
    const inputElement = signal.value.target as HTMLInputElement;
    const value = Number(inputElement.value);
    const logScale = logMin + (value / 100) * (logMax - logMin);
    const scale = clamp(Math.exp(logScale), MIN_SCALE, MAX_SCALE);
    zoomManager.setScale(scale);
    updateZoomInfo("dom");
  });

  // Pan -> 3D Rotation
  pan(box, { threshold: 5 })
    .pipe(
      rotate3d({
        sensitivityX: 0.5,
        sensitivityY: 0.5,
      }),
    )
    .on((signal) => {
      const [drx, dry, drz] = signal.value.rotation;
      rotationManager.addDelta(drx, dry, drz);
      updateRotationInfo("pan");
    });
}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initSpacePinchZoom);
} else {
  initSpacePinchZoom();
}

function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}
</script>
