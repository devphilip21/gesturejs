---
/**
 * Interactive space canvas demo that uses pinch gesture to zoom in/out.
 * Stars and nebulae are drawn on a canvas, with transform applied for zooming.
 */
import "./space-adventure.css";
---

<div class="space-adventure">
  <div class="_demo-box" id="space-box">
    <canvas id="space-canvas"></canvas>
    <strong id="space-zoom-mode" class="_zoom-mode">Zoom Mode</strong>
    <div class="_tip">
      <strong class="_tip-title">Tip.</strong>
      Pinch, double tap, or change slider to zoom.<br />
      In Desktop, use 'z' + '+/-' or 'wheel' to zoom.
    </div>
  </div>
  <div class="_demo-controls">
    <div class="_slider-container">
      <span class="_slider-label">Zoom</span>
      <input type="range" id="zoom-slider" class="_slider" min="0" max="100" value="50" />
    </div>
    <div class="_buttons">
      <button id="reset-space" type="button" class="_button">Reset</button>
    </div>
  </div>
  <div class="_signal-snapshot-grid" id="space-info-panel">
    <strong class="_title">Signal Snapshot</strong>
    <div class="_grid">
      <div class="_item">
        <span class="_label">SCALE</span>
        <span class="_value" id="info-scale">1.00</span>
      </div>
      <div class="_item">
        <span class="_label">INPUT</span>
        <span class="_value" id="info-source">-</span>
      </div>
    </div>
  </div>
</div>

<script>
import { wheel, keydown, keyheld, type KeyboardSignal, type WheelSignal, domEvent, type KeyboardValue, type Signal } from "cereb";
import { zoom as createZoom, extend, when, spy, filter, type ZoomInput, type ZoomOptions } from "cereb/operators";
import { pinch } from "@cereb/pinch";
import { tap, type TapSignal } from "@cereb/tap";

interface Star {
  x: number;
  y: number;
  z: number;
  baseRadius: number;
  brightness: number;
  twinkleSpeed: number;
  twinklePhase: number;
  color: string;
}

interface ShootingStar {
  x: number;
  y: number;
  angle: number;
  speed: number;
  length: number;
  opacity: number;
  life: number;
  maxLife: number;
}

interface Sun {
  x: number;
  y: number;
  radius: number;
}

interface Planet {
  name: string;
  orbitRadius: number;
  orbitAngle: number;
  orbitSpeed: number;
  rotationAngle: number;
  rotationSpeed: number;
  radius: number;
  color: string;
  hasRings?: boolean;
}

/**
 * Renders a 3D parallax space scene with multiple star layers,
 * animated nebulae, occasional shooting stars, and a solar system.
 *
 * Uses a virtual world coordinate system (6x canvas size) to enable
 * zoom-out without showing empty edges. All rendering is done by
 * transforming world coordinates to canvas coordinates based on
 * current scale and center position.
 */
class SpaceRenderer {
  private ctx: CanvasRenderingContext2D;
  private starLayers: Star[][] = [];
  private shootingStars: ShootingStar[] = [];
  private sun!: Sun;
  private planets: Planet[] = [];
  private animationId: number | null = null;
  private driftX = 0;
  private driftY = 0;
  private readonly LAYER_COUNT = 4;
  private readonly LAYER_SPEEDS = [0.02, 0.05, 0.1, 0.2];

  // Virtual world is 6x canvas size to fit full solar system
  private readonly WORLD_SCALE = 6;
  private worldWidth = 0;
  private worldHeight = 0;

  // Current view state
  private viewScale = 1;
  private viewCenterX = 0.5; // 0~1 ratio within world
  private viewCenterY = 0.5;

  constructor(
    private canvas: HTMLCanvasElement,
    private container: HTMLElement
  ) {
    this.ctx = canvas.getContext("2d")!;
    this.setupCanvas();
    this.generateSpace();
    this.startAnimation();
  }

  private setupCanvas() {
    this.resize();
    window.addEventListener("resize", () => {
      this.resize();
      this.generateSpace();
    });
  }

  private resize() {
    const rect = this.container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    // Virtual world is 4x canvas size
    this.worldWidth = this.canvas.width * this.WORLD_SCALE;
    this.worldHeight = this.canvas.height * this.WORLD_SCALE;
  }

  /**
   * Updates the view state for zoom/pan.
   * @param scale - Zoom scale (1 = normal, 0.25 = zoomed out to see full world)
   * @param centerX - View center X as ratio (0~1) within world
   * @param centerY - View center Y as ratio (0~1) within world
   */
  setView(scale: number, centerX: number, centerY: number) {
    this.viewScale = scale;
    this.viewCenterX = centerX;
    this.viewCenterY = centerY;
  }

  getViewScale() {
    return this.viewScale;
  }

  /**
   * Transforms world coordinates to canvas coordinates based on current view.
   */
  private worldToCanvas(wx: number, wy: number): [number, number] {
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    // Viewport size in world coordinates (smaller scale = larger viewport)
    const viewportW = canvasW / this.viewScale;
    const viewportH = canvasH / this.viewScale;

    // Viewport center in world coordinates
    const viewCenterWX = this.worldWidth * this.viewCenterX;
    const viewCenterWY = this.worldHeight * this.viewCenterY;

    // Viewport top-left in world coordinates
    const viewX = viewCenterWX - viewportW / 2;
    const viewY = viewCenterWY - viewportH / 2;

    // Transform world to canvas
    const cx = (wx - viewX) * this.viewScale;
    const cy = (wy - viewY) * this.viewScale;

    return [cx, cy];
  }

  /**
   * Transforms a radius from world space to canvas space.
   */
  private worldRadiusToCanvas(radius: number): number {
    return radius * this.viewScale;
  }

  private generateSpace() {
    this.generateStarLayers();
    this.generateSolarSystem();
  }

  private generateSolarSystem() {
    this.sun = {
      x: this.worldWidth / 2,
      y: this.worldHeight / 2,
      radius: 80,
    };

    // Distances spread to fill view at minimum zoom
    this.planets = [
      {
        name: "mercury",
        orbitRadius: 250,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0020,
        rotationAngle: 0,
        rotationSpeed: 0.004,
        radius: 10,
        color: "#b5b5b5",
      },
      {
        name: "venus",
        orbitRadius: 450,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0014,
        rotationAngle: 0,
        rotationSpeed: 0.003,
        radius: 32,
        color: "#e6c87a",
      },
      {
        name: "earth",
        orbitRadius: 650,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0008,
        rotationAngle: 0,
        rotationSpeed: 0.015,
        radius: 36,
        color: "#4a90d9",
      },
      {
        name: "mars",
        orbitRadius: 900,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.0006,
        rotationAngle: 0,
        rotationSpeed: 0.014,
        radius: 18,
        color: "#c1440e",
      },
      {
        name: "jupiter",
        orbitRadius: 1300,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00035,
        rotationAngle: 0,
        rotationSpeed: 0.025,
        radius: 85,
        color: "#d4a574",
      },
      {
        name: "saturn",
        orbitRadius: 1800,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00025,
        rotationAngle: 0,
        rotationSpeed: 0.022,
        radius: 70,
        color: "#e8d5a3",
        hasRings: true,
      },
      {
        name: "uranus",
        orbitRadius: 2350,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00018,
        rotationAngle: 0,
        rotationSpeed: 0.018,
        radius: 45,
        color: "#7de3e3",
      },
      {
        name: "neptune",
        orbitRadius: 2900,
        orbitAngle: Math.random() * Math.PI * 2,
        orbitSpeed: 0.00012,
        rotationAngle: 0,
        rotationSpeed: 0.016,
        radius: 42,
        color: "#5b8edd",
      },
    ];
  }

  private generateStarLayers() {
    this.starLayers = [];
    const starColors = ["#ffffff", "#ffe8d0", "#d0e8ff", "#ffd8e8", "#d8ffe8", "#e8d8ff"];

    // Generate stars across the entire virtual world
    for (let layer = 0; layer < this.LAYER_COUNT; layer++) {
      const stars: Star[] = [];
      const depth = (layer + 1) / this.LAYER_COUNT;
      // Increased star count (1.5x more stars)
      const starCount = Math.floor((75 + (1 - depth) * 225) * this.WORLD_SCALE);

      for (let i = 0; i < starCount; i++) {
        const isBright = Math.random() < 0.05 + depth * 0.1;
        stars.push({
          x: Math.random() * this.worldWidth,
          y: Math.random() * this.worldHeight,
          z: depth,
          // Increased base radius so stars remain visible when zoomed out
          baseRadius: isBright ? 2.5 + Math.random() * 3.0 : 0.8 + Math.random() * 1.5,
          brightness: 0.4 + Math.random() * 0.6,
          twinkleSpeed: 0.3 + Math.random() * 1.5,
          twinklePhase: Math.random() * Math.PI * 2,
          color: starColors[Math.floor(Math.random() * starColors.length)],
        });
      }
      this.starLayers.push(stars);
    }
  }

  private spawnShootingStar() {
    if (this.shootingStars.length >= 2 || Math.random() > 0.002) return;

    // Spawn shooting stars in the virtual world
    this.shootingStars.push({
      x: Math.random() * this.worldWidth,
      y: Math.random() * this.worldHeight * 0.3,
      angle: Math.PI * 0.2 + Math.random() * Math.PI * 0.2,
      speed: 4 + Math.random() * 4,
      length: 60 + Math.random() * 80,
      opacity: 0.8 + Math.random() * 0.2,
      life: 0,
      maxLife: 80 + Math.random() * 40,
    });
  }

  private startAnimation() {
    let lastTime = 0;
    const animate = (time: number) => {
      const delta = Math.min((time - lastTime) / 16.67, 2);
      lastTime = time;

      this.driftX += 0.015 * delta;
      this.driftY += 0.008 * delta;

      this.spawnShootingStar();
      this.render(time, delta);
      this.animationId = requestAnimationFrame(animate);
    };
    this.animationId = requestAnimationFrame(animate);
  }

  private render(time: number, delta: number) {
    const ctx = this.ctx;
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    // Clear with background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvasH);
    gradient.addColorStop(0, "#05050f");
    gradient.addColorStop(0.5, "#0a0a1a");
    gradient.addColorStop(1, "#080815");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvasW, canvasH);

    this.renderStarLayers(ctx, time);
    this.renderOrbitPaths(ctx);
    this.renderSolarSystem(ctx, time, delta);
    this.renderShootingStars(ctx, delta);
  }

  private renderSolarSystem(ctx: CanvasRenderingContext2D, time: number, delta: number) {
    // Update all planet positions first
    for (const planet of this.planets) {
      planet.orbitAngle += planet.orbitSpeed * delta;
      planet.rotationAngle += planet.rotationSpeed * delta;
    }

    // Separate planets into behind and in front of sun (based on orbit position)
    const behindSun = this.planets.filter(p => Math.sin(p.orbitAngle) > 0);
    const inFrontOfSun = this.planets.filter(p => Math.sin(p.orbitAngle) <= 0);

    // Sort each group by depth
    behindSun.sort((a, b) => Math.sin(a.orbitAngle) - Math.sin(b.orbitAngle));
    inFrontOfSun.sort((a, b) => Math.sin(a.orbitAngle) - Math.sin(b.orbitAngle));

    // Draw: planets behind -> sun -> planets in front
    this.renderPlanetGroup(ctx, behindSun);
    this.renderSun(ctx, time);
    this.renderPlanetGroup(ctx, inFrontOfSun);
  }

  private renderStarLayers(ctx: CanvasRenderingContext2D, time: number) {
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    for (let layerIdx = 0; layerIdx < this.starLayers.length; layerIdx++) {
      const layer = this.starLayers[layerIdx];
      const speed = this.LAYER_SPEEDS[layerIdx];

      for (const star of layer) {
        const parallaxX = this.driftX * speed * 50;
        const parallaxY = this.driftY * speed * 50;

        // World coordinates with parallax and wrapping
        let worldX = (star.x - parallaxX) % this.worldWidth;
        let worldY = (star.y - parallaxY) % this.worldHeight;
        if (worldX < 0) worldX += this.worldWidth;
        if (worldY < 0) worldY += this.worldHeight;

        // Transform to canvas coordinates
        const [x, y] = this.worldToCanvas(worldX, worldY);

        // Cull if outside visible area
        if (x < -10 || x > canvasW + 10 || y < -10 || y > canvasH + 10) continue;

        const twinkle = Math.sin(time * 0.001 * star.twinkleSpeed + star.twinklePhase);
        const currentBrightness = star.brightness * (0.6 + twinkle * 0.4);
        const depthScale = 0.5 + star.z * 0.5;
        const worldRadius = star.baseRadius * depthScale;
        // Ensure minimum visible size even when zoomed out
        const radius = Math.max(0.4, this.worldRadiusToCanvas(worldRadius));

        ctx.globalAlpha = currentBrightness * depthScale;
        ctx.fillStyle = star.color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        if (radius > 1.5 && currentBrightness > 0.7) {
          const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 5);
          glowGradient.addColorStop(0, star.color);
          glowGradient.addColorStop(0.3, star.color.replace(")", ", 0.3)").replace("rgb", "rgba"));
          glowGradient.addColorStop(1, "transparent");
          ctx.fillStyle = glowGradient;
          ctx.globalAlpha = currentBrightness * 0.25;
          ctx.beginPath();
          ctx.arc(x, y, radius * 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    ctx.globalAlpha = 1;
  }

  private renderShootingStars(ctx: CanvasRenderingContext2D, delta: number) {
    const canvasW = this.canvas.width;
    const canvasH = this.canvas.height;

    for (let i = this.shootingStars.length - 1; i >= 0; i--) {
      const star = this.shootingStars[i];
      star.life += delta;
      // Update position in world coordinates
      star.x += Math.cos(star.angle) * star.speed * delta;
      star.y += Math.sin(star.angle) * star.speed * delta;

      const lifeRatio = star.life / star.maxLife;
      const fadeIn = Math.min(lifeRatio * 5, 1);
      const fadeOut = 1 - Math.pow(lifeRatio, 2);
      const opacity = star.opacity * fadeIn * fadeOut;

      // Remove if life expired or outside world
      if (star.life >= star.maxLife || star.x > this.worldWidth + 50 || star.y > this.worldHeight + 50) {
        this.shootingStars.splice(i, 1);
        continue;
      }

      // Transform to canvas coordinates
      const [headX, headY] = this.worldToCanvas(star.x, star.y);
      const tailWorldX = star.x - Math.cos(star.angle) * star.length;
      const tailWorldY = star.y - Math.sin(star.angle) * star.length;
      const [tailX, tailY] = this.worldToCanvas(tailWorldX, tailWorldY);

      // Cull if completely outside canvas
      if (Math.max(headX, tailX) < 0 || Math.min(headX, tailX) > canvasW ||
          Math.max(headY, tailY) < 0 || Math.min(headY, tailY) > canvasH) continue;

      const gradient = ctx.createLinearGradient(tailX, tailY, headX, headY);
      gradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
      gradient.addColorStop(0.7, `rgba(200, 220, 255, ${opacity * 0.5})`);
      gradient.addColorStop(1, `rgba(255, 255, 255, ${opacity})`);

      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2 * this.viewScale;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(headX, headY);
      ctx.stroke();

      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.beginPath();
      ctx.arc(headX, headY, 2 * this.viewScale, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Tilt factor for 3D perspective (0 = top-down, 1 = side view)
  private readonly ORBIT_TILT = 0.3;

  private renderOrbitPaths(ctx: CanvasRenderingContext2D) {
    const [sunX, sunY] = this.worldToCanvas(this.sun.x, this.sun.y);

    ctx.strokeStyle = "rgba(255, 255, 255, 0.12)";
    ctx.lineWidth = 1;

    for (const planet of this.planets) {
      const orbitRadiusX = this.worldRadiusToCanvas(planet.orbitRadius);
      const orbitRadiusY = orbitRadiusX * this.ORBIT_TILT;
      ctx.beginPath();
      ctx.ellipse(sunX, sunY, orbitRadiusX, orbitRadiusY, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  private renderSun(ctx: CanvasRenderingContext2D, _time: number) {
    const [x, y] = this.worldToCanvas(this.sun.x, this.sun.y);
    const radius = this.worldRadiusToCanvas(this.sun.radius);

    // Cull if outside visible area
    if (x + radius * 3 < 0 || x - radius * 3 > this.canvas.width ||
        y + radius * 3 < 0 || y - radius * 3 > this.canvas.height) return;

    // Outer corona glow
    const coronaGradient = ctx.createRadialGradient(x, y, radius * 0.5, x, y, radius * 2.5);
    coronaGradient.addColorStop(0, "rgba(255, 200, 100, 0.3)");
    coronaGradient.addColorStop(0.4, "rgba(255, 150, 50, 0.15)");
    coronaGradient.addColorStop(1, "rgba(255, 100, 0, 0)");
    ctx.fillStyle = coronaGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius * 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Main sun body
    const sunGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    sunGradient.addColorStop(0, "#fffef0");
    sunGradient.addColorStop(0.3, "#ffee88");
    sunGradient.addColorStop(0.7, "#ffcc33");
    sunGradient.addColorStop(1, "#ff8800");
    ctx.fillStyle = sunGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();

    // Inner bright core
    const coreGradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 0.4);
    coreGradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
    coreGradient.addColorStop(1, "rgba(255, 255, 200, 0)");
    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }

  private renderPlanetGroup(ctx: CanvasRenderingContext2D, planets: Planet[]) {
    for (const planet of planets) {
      // Calculate planet's world position with tilted orbit
      const planetWorldX = this.sun.x + Math.cos(planet.orbitAngle) * planet.orbitRadius;
      const planetWorldY = this.sun.y + Math.sin(planet.orbitAngle) * planet.orbitRadius * this.ORBIT_TILT;

      const [x, y] = this.worldToCanvas(planetWorldX, planetWorldY);
      const radius = this.worldRadiusToCanvas(planet.radius);

      // Cull if outside visible area
      const cullRadius = planet.hasRings ? radius * 2.5 : radius;
      if (x + cullRadius < 0 || x - cullRadius > this.canvas.width ||
          y + cullRadius < 0 || y - cullRadius > this.canvas.height) continue;

      // Draw Saturn's rings behind the planet
      if (planet.hasRings) {
        this.renderSaturnRings(ctx, x, y, radius, planet.rotationAngle);
      }

      // Draw planet body with crisp edges
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.clip();

      // Planet gradient
      const planetGradient = ctx.createRadialGradient(
        x - radius * 0.3, y - radius * 0.3, 0,
        x, y, radius
      );

      if (planet.name === "earth") {
        // Earth with continents
        planetGradient.addColorStop(0, "#4a90d9");
        planetGradient.addColorStop(0.5, "#2e6ab3");
        planetGradient.addColorStop(1, "#1a4a7a");
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

        // Continents
        const continentOffset = planet.rotationAngle * 0.5;
        ctx.fillStyle = "#3d8b4a";
        for (let i = 0; i < 3; i++) {
          const angle = continentOffset + (i * Math.PI * 2) / 3;
          const cx = x + Math.cos(angle) * radius * 0.4;
          const cy = y + Math.sin(angle * 0.5) * radius * 0.3;
          ctx.beginPath();
          ctx.ellipse(cx, cy, radius * 0.35, radius * 0.25, angle, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (planet.name === "jupiter") {
        // Jupiter with bands
        planetGradient.addColorStop(0, "#e8cba8");
        planetGradient.addColorStop(0.5, "#d4a574");
        planetGradient.addColorStop(1, "#a67c52");
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

        // Horizontal bands
        ctx.fillStyle = "rgba(180, 120, 80, 0.4)";
        for (let i = -2; i <= 2; i++) {
          ctx.fillRect(x - radius, y + i * radius * 0.3 - radius * 0.08, radius * 2, radius * 0.16);
        }
      } else if (planet.name === "mars") {
        // Mars with polar caps
        planetGradient.addColorStop(0, "#e07050");
        planetGradient.addColorStop(0.5, "#c1440e");
        planetGradient.addColorStop(1, "#8b3010");
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

        // Polar cap
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.ellipse(x, y - radius * 0.7, radius * 0.4, radius * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Generic planet
        const baseColor = planet.color;
        const r = parseInt(baseColor.slice(1, 3), 16);
        const g = parseInt(baseColor.slice(3, 5), 16);
        const b = parseInt(baseColor.slice(5, 7), 16);

        planetGradient.addColorStop(0, `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`);
        planetGradient.addColorStop(0.5, baseColor);
        planetGradient.addColorStop(1, `rgb(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)})`);
        ctx.fillStyle = planetGradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
      }

      // Day/night shadow
      const sunAngle = Math.atan2(this.sun.y - planetWorldY, this.sun.x - planetWorldX);
      const shadowGradient = ctx.createRadialGradient(
        x + Math.cos(sunAngle) * radius * 0.5,
        y + Math.sin(sunAngle) * radius * 0.5,
        0,
        x - Math.cos(sunAngle) * radius * 0.3,
        y - Math.sin(sunAngle) * radius * 0.3,
        radius * 1.2
      );
      shadowGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
      shadowGradient.addColorStop(0.5, "rgba(0, 0, 20, 0.3)");
      shadowGradient.addColorStop(1, "rgba(0, 0, 30, 0.7)");
      ctx.fillStyle = shadowGradient;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);

      ctx.restore();
    }
  }

  private renderSaturnRings(ctx: CanvasRenderingContext2D, x: number, y: number, planetRadius: number, _rotation: number) {
    const innerRadius = planetRadius * 1.3;
    const outerRadius = planetRadius * 2.2;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(1, 0.3); // Tilt the rings

    // Ring gradient
    const ringGradient = ctx.createRadialGradient(0, 0, innerRadius, 0, 0, outerRadius);
    ringGradient.addColorStop(0, "rgba(210, 180, 140, 0)");
    ringGradient.addColorStop(0.1, "rgba(210, 180, 140, 0.6)");
    ringGradient.addColorStop(0.3, "rgba(180, 150, 110, 0.4)");
    ringGradient.addColorStop(0.5, "rgba(210, 180, 140, 0.5)");
    ringGradient.addColorStop(0.7, "rgba(180, 150, 110, 0.3)");
    ringGradient.addColorStop(1, "rgba(210, 180, 140, 0)");

    ctx.fillStyle = ringGradient;
    ctx.beginPath();
    ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
    ctx.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
    ctx.fill();

    ctx.restore();
  }

  regenerate() {
    this.driftX = 0;
    this.driftY = 0;
    this.shootingStars = [];
    this.viewScale = 1;
    this.viewCenterX = 0.5;
    this.viewCenterY = 0.5;
    this.generateSpace();
  }

  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}

/**
 * Manages zoom state and updates SpaceRenderer's view.
 * No CSS transforms - all zooming is handled by the renderer's coordinate system.
 */
class ZoomManager {
  private currentScale = 1;
  private baseScale = 1;
  private centerX = 0.5; // View center as ratio (0~1) in world
  private centerY = 0.5;

  constructor(
    private container: HTMLElement,
    private renderer: SpaceRenderer,
  ) {
    this.applyView();
  }

  private applyView() {
    this.renderer.setView(this.currentScale, this.centerX, this.centerY);
  }

  reset() {
    this.currentScale = 1;
    this.baseScale = 1;
    this.centerX = 0.5;
    this.centerY = 0.5;
    this.applyView();
  }

  getScale() {
    return this.currentScale;
  }

  setScale(newScale: number) {
    this.currentScale = newScale;
    this.applyView();
  }

  adjustScale(delta: number) {
    this.setScale(this.currentScale + delta);
  }
}

function initSpacePinchZoom() {
  const box = document.getElementById("space-box");
  const canvas = document.getElementById("space-canvas") as HTMLCanvasElement;
  const resetBtn = document.getElementById("reset-space");
  const slider = document.getElementById("zoom-slider") as HTMLInputElement;
  const infoScale = document.getElementById("info-scale");
  const infoSource = document.getElementById("info-source");

  if (!box || !canvas || !resetBtn || !slider || !infoScale || !infoSource) {
    return;
  }

  const MIN_SCALE = 0.2;
  const MAX_SCALE = 5;
  const logMin = Math.log(MIN_SCALE);
  const logMax = Math.log(MAX_SCALE);

  const spaceRenderer = new SpaceRenderer(canvas, box);
  const zoomManager = new ZoomManager(box, spaceRenderer);

  const syncSlider = (scale: number) => {
    const logScale = Math.log(scale);
    const value = ((logScale - logMin) / (logMax - logMin)) * 100;
    slider.value = String(value);
  };

  const updateInfo = (source: string) => {
    infoScale.textContent = zoomManager.getScale().toFixed(2);
    infoSource.textContent = source;
    syncSlider(zoomManager.getScale());
  };

  syncSlider(zoomManager.getScale());

  resetBtn.addEventListener("click", () => {
    zoomManager.reset();
    spaceRenderer.regenerate();
    box.classList.remove("active");
    syncSlider(1);
    infoScale.textContent = "1.00";
    infoSource.textContent = "-";
  });

  const render = <T extends { kind: string; value: { scale: number } }>(
    signal: T
  ) => {
    zoomManager.setScale(signal.value.scale);
    updateInfo(signal.kind);
  }

  const zoomMode$ = keyheld(window, { code: "KeyZ" }).pipe(extend((signal) => ({ opened: signal.value.held })));
  const zoomModeIndicator = document.getElementById("space-zoom-mode");
  const zoom = (options: ZoomOptions = {}) => createZoom({ minScale: MIN_SCALE, maxScale: MAX_SCALE, baseScale: () => zoomManager.getScale(), ...options });

  zoomMode$.on((signal) => {
    zoomModeIndicator?.classList.toggle("active", signal.value.held);
  });

  // Pinch Zoom (dampened for smoother experience)
  const PINCH_SENSITIVITY = 0.4; // 0~1, lower = less sensitive
  pinch(box, { threshold: 10 })
    .pipe(
      extend((signal) => ({
        ratio: 1 + (signal.value.ratio - 1) * PINCH_SENSITIVITY,
      })),
      zoom(),
    )
    .on(render);

  // Double Tap Zoom
  const DOUBLE_TAP_ZOOM_MULTIPLIER = 2.5;
  tap(box, { chainIntervalThreshold: 300 })
    .pipe(
      filter((signal) => signal.value.tapCount === 2),
      extend<TapSignal, ZoomInput>(() => {
        const currentScale = zoomManager.getScale();
        const isNearMax = currentScale >= MAX_SCALE * 0.9;
        return {
          ratio: isNearMax ? 1 : Math.min(currentScale * DOUBLE_TAP_ZOOM_MULTIPLIER, MAX_SCALE),
        };
      }),
      zoom({ baseScale: 1.0 }),
    )
    .on(render);

  // 'z' + '+/-' (logarithmic zoom: multiply by 1.2 or 1/1.2)
  keydown(window, { code: ["Equal", "Minus"] })
    .pipe(
      when(zoomMode$),
      spy((signal) => signal.value.originalEvent.preventDefault()),
      extend<KeyboardSignal, ZoomInput>((signal) => ({
        ratio: zoomManager.getScale() * (signal.value.code === "Equal" ? 1.2 : 1 / 1.2),
      })),
      zoom({ baseScale: 1.0 }),
    )
    .on(render);

  // 'z' + 'wheel'
  wheel(box, { passive: false })
    .pipe(
      when(zoomMode$),
      spy((signal) => signal.value.originalEvent.preventDefault()),
      extend<WheelSignal, ZoomInput>((signal) => ({
        ratio: zoomManager.getScale() * Math.exp(-signal.value.deltaY * 0.005),
      })),
      zoom({ baseScale: 1.0 }),
    )
    .on(render);

  // 'Progress' - slider sets absolute scale (baseScale=1 so ratio becomes the scale directly)
  domEvent(slider, "input")
    .pipe(
      extend<Signal<"dom-event", Event>, ZoomInput>((signal) => {
        const inputElement = signal.value.target as HTMLInputElement;
        const value = Number(inputElement.value);
        const logScale = logMin + (value / 100) * (logMax - logMin);
        const scale = Math.exp(logScale);
        return {
          ratio: clamp(scale, MIN_SCALE, MAX_SCALE),
        };
      }),
      zoom({ baseScale: 1.0 }),
    )
    .on(render);
}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initSpacePinchZoom);
} else {
  initSpacePinchZoom();
}

function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}
</script>
